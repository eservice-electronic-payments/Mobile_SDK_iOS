//
//  ThreeDS2VerificationService.swift
//  EvoPayments
//
//  Created by Adrian Zyga on 29/08/2020.
//  Copyright Â© 2020 Intelligent Payments. All rights reserved.
//

import ipworks3ds_sdk

/// Protocol designed for the types that want to be able to handle 3DSV2 payments
protocol ThreeDS2VerificationServiceProtocol {
    func generateRequest() throws -> PaymentRequest
    func startChallenge(
        _ threeDS2Challenge: ThreeDS2Challenge,
        timeout: Int,
        completion: @escaping ((Result<ThreeDS2PaymentStatus, Error>) -> Void)
    )
}

/**
 * Service that wraps the NSoftware SDK and handles 3DSV2 challenges for credit cards.
 * This service is bound to one payment server, provided in `init`. It allows for one
 * or many transaction to the same server. To create a transaction with another server,
 * create another instance of this service.
 */
final class ThreeDS2VerificationService: ThreeDS2VerificationServiceProtocol {

    /// Instance that is responsible for creating a transaction.
    private let transactionBuilder: TransactionBuilderProtocol

    /**
     * String identyfing directory server that will be chosen for transaction.
     * This has to match with one of the RID from the server list in `directoryServerInfoList`.
     * Current implementation handles only one server so `verificationData.RID` has to be
     * the same as verificationData.directoryServerID
     */
    private let directoryServerID: String

    /// Message version used internally by the NSofware SDK
    private let messageVersion: String

    /// ViewController that will be used for displaying the challenge
    private let viewController: ViewControllerProtocol

    /// Transaction generated by the transaction builder. Instance of this type will create a challenge
    private var currentTransaction: TransactionProtocol?

    /// Action that will be executed asynchronously after the result of the challenge will be known
    private var verificationCompletion: ((Result<ThreeDS2PaymentStatus, Error>) -> Void)?

    /**
     * Constructor for the service
     * - Parameters:
     *    - verificationData: All the data that is needed to create a correct transaction
     *    - transactionBuilder: Instance that is responsible for creating a transaction.
     *      You can use NSofware's SDK `ThreeDS2Service` instance as a transaction builder.
     * - Returns: `ThreeDS2VerificationService` instance or `nil` if the verification data is bad
     */
    init?(
        verificationData: Verification3DServiceData,
        transactionBuilder: TransactionBuilderProtocol,
        viewControler: ViewControllerProtocol
    ) {
        self.transactionBuilder = transactionBuilder
        self.viewController = viewControler
        do {
            let uiCustomization = UiCustomization()
            let directoryServerInfoList = [
                DirectoryServerInfo(
                    RID: verificationData.RID,
                    publicKey: verificationData.publicKey,
                    CA: verificationData.CA
                )
            ]
            let clientConfigs = verificationData.clientConfigs
            let builder = ConfigParametersBuilder(
                directoryServerInfoList: directoryServerInfoList,
                runtimeLicense: verificationData.runtimeLicense,
                deviceParameterBlacklist: nil,
                clientConfig: clientConfigs,
                appBundleID: ""
            )
            let configParameters = try builder.build()
            directoryServerID = verificationData.directoryServerID
            messageVersion = verificationData.messageVersion

            try verificationData.configParameters.forEach { (key, value) in
                try configParameters.addParam(group: nil, paramName: key, paramValue: value)
            }

            try transactionBuilder.initialize(
                configParameters: configParameters,
                locale: Locale.preferredLanguages.first,
                uiCustomization: uiCustomization,
                clientEventListener: self,
                securityEventListener: nil
            )
        } catch {
            dLog("Could not initialize ThreeDS2VerificationService. Reason: \(error)")
            return nil
        }
    }

    /**
     * Generate new transaction and extract all the data from the transaction into a `PaymentRequest`
     * - Throws: Errors passed by the `createTransactionProtocol` method of the transactionBuilder
     * - Returns: `PaymentRequest` containing all the data needed by the webview to
     *   decide if the challenge is needed, or is it a frictionless payment. This data allows
     *   webview to generate a challenge
     */
    func generateRequest() throws -> PaymentRequest {
        do {
            let transaction = try transactionBuilder.createTransactionProtocol(directoryServerID, messageVersion)
            currentTransaction = transaction
            let authenticationRequestParameters = try transaction.getAuthenticationRequestParametersProtocol()
            let sdkEphemeralPublicKeyString = authenticationRequestParameters.getSDKEphemeralPublicKey()

            guard let sdkEphemeralPublicKeyData = sdkEphemeralPublicKeyString.data(using: .utf8) else {
                throw EncodingError.invalidValue(
                    sdkEphemeralPublicKeyString,
                    EncodingError.Context(
                        codingPath: [],
                        debugDescription: "Could not encode sdkEphemeralPublicKeyString using .utf8 as Data"
                    )
                )
            }

            let sdkEphemeralPublicKey = try SDKEphemeralPublicKey(data: sdkEphemeralPublicKeyData)

            return PaymentRequest(
                sdkTransactionId: authenticationRequestParameters.getSDKTransactionID(),
                deviceData: authenticationRequestParameters.getDeviceData(),
                sdkEphemeralPublicKey: sdkEphemeralPublicKey,
                sdkAppId: authenticationRequestParameters.getSDKAppID(),
                sdkReferenceNumber: authenticationRequestParameters.getSDKReferenceNumber(),
                protocolVersionSDK: authenticationRequestParameters.getMessageVersion()
            )
        } catch {
            cleanup()
            throw error
        }
    }

    /**
     * Generate new transaction and extract all the data from the transaction into a `PaymentRequest`
     * - Parameters:
     *      - threeDS2Challenge: All the data needed to generate a challenge for the user
     *      - timeout: Number of seconds for the challenge to load after which the payment will fail
     *      - completion: Action that needs to be executed after the result of challenge is known.
     *          Most commonly UI update is added here
     */
    func startChallenge(
        _ threeDS2Challenge: ThreeDS2Challenge,
        timeout: Int,
        completion: @escaping ((Result<ThreeDS2PaymentStatus, Error>) -> Void)
    ) {
        verificationCompletion = completion

        let challengeParameters = ChallengeParameters(
            threeDSServerTransactionID: threeDS2Challenge.threeDSServerTransactionID,
            acsTransactionID: threeDS2Challenge.acsTransactionID,
            acsRefNumber: threeDS2Challenge.acsRefNumber,
            acsSignedContent: threeDS2Challenge.acsSignedContent,
            threeDSRequestorAppURL: ""
        )

        do {
            try currentTransaction?.doChallenge(
                rootViewController: self.viewController,
                challengeParameters: challengeParameters,
                challengeStatusReceiver: self,
                timeout: timeout
            )
        } catch {
            verificationCompletion?(.failure(error))
            cleanup()
        }
    }

    /**
     * Cleans up the current transaction, so another transaction with the same server can be created
     * - Warning: This does not close the transaction builder that is bound to a specific server.
     * To create a new transaction with another directory server, create a new instance of
     * ThreeDS2VerificationService
     */
    private func cleanup() {
        try? currentTransaction?.close()
        currentTransaction = nil
        verificationCompletion = nil
    }
}

/// Implementation of `ClientEventListener` protocol for logging porpuses
extension ThreeDS2VerificationService: ClientEventListener {

    func onDataPacketIn(_ dataPacket: Data) {
        dLog("ThreeDS2Service log: Data packet in. Size: \(dataPacket.count) Bytes")
    }

    func onDataPacketOut(_ dataPacket: Data) {
        dLog("ThreeDS2Service log: Data packet out. Size: \(dataPacket.count) Bytes")
    }

    func onError(_ errorCode: Int32, _ description: String) {
        dLog("ThreeDS2Service log: Error number \(errorCode): \(description)")
    }

    func onLog(_ logLevel: Int32, _ message: String, _ logType: String) {
        dLog("ThreeDS2Service log: [\(logType)]\(message)")
    }

    func onSSLServerAuthentication(
        _ certEncoded: Data,
        _ certSubject: String,
        _ certIssuer: String,
        _ status: String,
        _ accept: UnsafeMutablePointer<Int32>
    ) {
        dLog("ThreeDS2Service log: SSL Authentication Status: \(status)")
    }

    func onSSLStatus(_ message: String) {
        dLog("ThreeDS2Service log: SSL Status: \(message)")
    }
}

/// Implementation of `ChallengeStatusReceiver` protocol that handles the result of a challenge once it is known
extension ThreeDS2VerificationService: ChallengeStatusReceiver {

    func completed(_ completionEvent: ipworks3ds_sdk.CompletionEvent) {
        let status = ThreeDS2PaymentStatus(
            transactionID: completionEvent.getSDKTransactionID(),
            status: completionEvent.getTransactionStatus(),
            errorCode: nil,
            errorDescription: nil,
            errorDetails: nil,
            errorMessage: nil
        )
        verificationCompletion?(.success(status))
        cleanup()
    }

    func cancelled() {
        verificationCompletion?(.failure(ThreeDS2Error.cancelled))
        cleanup()
    }

    func timedout() {
        verificationCompletion?(.failure(ThreeDS2Error.timedout))
        cleanup()
    }

    func protocolError(_ protocolErrorEvent: ipworks3ds_sdk.ProtocolErrorEvent) {
        verificationCompletion?(
            .failure(
                ThreeDS2Error.protocolError(
                    errorCode: protocolErrorEvent.getErrorMessage().getErrorCode(),
                    errorDescription: protocolErrorEvent.getErrorMessage().getErrorDescription(),
                    errorDetails: protocolErrorEvent.getErrorMessage().getErrorDetails(),
                    transactionID: protocolErrorEvent.getErrorMessage().getTransactionID()
                )
            )
        )
        cleanup()
    }

    func runtimeError(_ runtimeErrorEvent: ipworks3ds_sdk.RuntimeErrorEvent) {
        verificationCompletion?(
            .failure(
                ThreeDS2Error.runtimeError(
                    errorCode: runtimeErrorEvent.getErrorCode(),
                    errorMessage: runtimeErrorEvent.getErrorMessage()
                )
            )
        )
        cleanup()
    }
}
